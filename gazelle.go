package cc

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/buildtools/build"
)

var cppHdrs = suffixes{
	".h",
	".hh",
}

var cppSrcs = suffixes{
	".h",
	".hh",
	".cc",
	".cpp",
}

var cppTests = suffixes{
	"_test.cc",
	"_test.cpp",
}

var ignoreSuffix = suffixes{}

// yolo
var cppImportRegex = regexp.MustCompile(`(?m)^#include "(.*)"`)
var mainFunctionRegex = regexp.MustCompile(`(?m)^int main\((int \w+, char \*\w+\[\])?\)`)

var languageName = "cc"

type suffixes []string

func (s suffixes) Matches(test string) bool {
	for _, v := range s {
		if strings.HasSuffix(test, v) {
			return true
		}
	}
	return false
}

func isCppSourceFile(f string) bool {
	return cppSrcs.Matches(f) && !ignoreSuffix.Matches(f)
}

var (
	PrefixesForExternalLibrariesFlag *string
)

type Extension struct {
}

// RegisterFlags registers command-line flags used by the extension. This
// method is called once with the root configuration when Gazelle
// starts. RegisterFlags may set an initial values in Config.Exts. When flags
// are set, they should modify these values.
func (e *Extension) RegisterFlags(fs *flag.FlagSet, cmd string, c *config.Config) {
}

// CheckFlags validates the configuration after command line flags are parsed.
// This is called once with the root configuration when Gazelle starts.
// CheckFlags may set default values in flags or make implied changes.
func (e *Extension) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	return nil
}

// KnownDirectives returns a list of directive keys that this Configurer can
// interpret. Gazelle prints errors for directives that are not recoginized by
// any Configurer.
func (e *Extension) KnownDirectives() []string {
	return nil
}

// Configure modifies the configuration using directives and other information
// extracted from a build file. Configure is called in each directory.
//
// c is the configuration for the current directory. It starts out as a copy
// of the configuration for the parent directory.
//
// rel is the slash-separated relative path from the repository root to
// the current directory. It is "" for the root directory itself.
//
// f is the build file for the current directory or nil if there is no
// existing build file.
func (e *Extension) Configure(c *config.Config, rel string, f *rule.File) {
}

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (e *Extension) Name() string {
	return "cc"
}

func (e *Extension) extractHdrs(r *rule.Rule, p string) []string {
	if res := r.AttrStrings("hdrs"); res != nil {
		return res
	}
	// parse glob expr, I could not find any existing implementation?!
	ce, ok := r.Attr("hdrs").(*build.CallExpr)
	if !ok {
		return nil
	}
	id, ok := ce.X.(*build.Ident)
	if !ok || id.Name != "glob" {
		log.Printf("unable to handle hdrs of %q: Must be a string or glob", r.Name())
		return nil
	}
	includes := build.Strings(ce.List[0])
	if includes == nil {
		log.Printf("unexpected glob expression: includes")
		return nil
	}
	excludes := map[string]bool{}
	if len(ce.List) > 1 {
		as, ok := ce.List[1].(*build.AssignExpr)
		if !ok {
			log.Printf("unexpected glob expression: excludes assign")
			return nil
		}
		if as.Op != "=" {
			log.Printf("unexpected glob expression: excludes op")
			return nil
		}
		if tk, ok := as.LHS.(*build.LiteralExpr); !ok || tk.Token != "exclude" {
			log.Printf("unexpected glob expression: excludes LHS")
			return nil
		}
		ex := build.Strings(as.RHS)
		if excludes == nil {
			log.Printf("unexpected glob expression: excludes RHS")
			return nil
		}
		for _, e := range ex {
			m, err := filepath.Glob(path.Join(p, e))
			if err != nil {
				log.Printf("error globbing %q: %v", e, err)
				return nil
			}
			for _, mm := range m {
				excludes[mm] = true
			}
		}

	}
	res := []string{}
	for _, i := range includes {
		m, err := filepath.Glob(path.Join(p, i))
		if err != nil {
			log.Printf("error globbing %q: %v", e, err)
			return nil
		}
		for _, mm := range m {
			if excludes[mm] {
				continue
			}
			res = append(res, strings.TrimPrefix(mm, p+"/"))
		}
	}
	return res
}

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (e *Extension) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	fp := f.Pkg
	if strings.HasPrefix(fp, "external/") {
		split := strings.Split(fp, string(os.PathSeparator))
		if len(split) >= 2 {
			fp = path.Join(split[2:]...)
		}
	}
	includes := r.AttrStrings("includes")
	if fp != "" && len(includes) != 0 {
		log.Printf("includes only supported in root dir, but got %q", fp)
		includes = nil
	}
	srcs := e.extractHdrs(r, path.Dir(f.Path))
	imports := make([]resolve.ImportSpec, 0, len(srcs))
	for _, src := range srcs {
		spec := resolve.ImportSpec{
			// Lang is the language in which the import string appears (this should
			// match Resolver.Name).
			Lang: "cc",
			// Imp is an import string for the library.
			Imp: fmt.Sprintf("%s", filepath.Join(fp, src)),
		}
		imports = append(imports, spec)
		for _, i := range includes {
			src := strings.TrimPrefix(src, i+"/")
			spec := resolve.ImportSpec{
				// Lang is the language in which the import string appears (this should
				// match Resolver.Name).
				Lang: "cc",
				// Imp is an import string for the library.
				Imp: fmt.Sprintf("%s", filepath.Join(fp, src)),
			}
			imports = append(imports, spec)
		}
	}
	return imports
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (e *Extension) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

func transformExternalLabel(l label.Label) label.Label {
	if !strings.HasPrefix(l.Pkg, "external/") {
		return l
	}
	split := strings.Split(l.Pkg, string(os.PathSeparator))
	if len(split) <= 1 {
		return l
	}
	return label.Label{
		Pkg:  path.Join(split[2:]...),
		Repo: split[1],
		Name: l.Name,
	}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (e *Extension) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	if strings.HasPrefix(from.Pkg, "external/") {
		return
	}
	// TODO this is just copied from skylark
	imports := importsRaw.([]string)

	r.DelAttr("deps")

	if len(imports) == 0 {
		return
	}

	deps := make([]string, 0, len(imports))
	for _, imp := range imports {
		dir := filepath.Dir(imp)
		if dir == "." {
			dir = ""
		}

		res := resolve.ImportSpec{
			Lang: languageName,
			Imp:  imp,
		}
		matches := ix.FindRulesByImport(res, languageName)
		if len(matches) == 0 {
			log.Printf("%s: %q was not found in dependency index. Skipping. This may result in an incomplete deps section and require manual BUILD file intervention.\n", from.String(), imp)
		}

		for _, m := range matches {
			if from.Equal(m.Label) {
				// no self dependencies
				continue
			}

			depLabel := transformExternalLabel(m.Label)
			depLabel = depLabel.Rel(from.Repo, from.Pkg)
			deps = append(deps, depLabel.String())
		}
	}

	sort.Strings(deps)
	if len(deps) > 0 {
		r.SetAttr("deps", deps)
	}
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (e *Extension) Kinds() map[string]rule.KindInfo {
	return kinds
}

var kinds = map[string]rule.KindInfo{
	"cc_library": {
		MatchAttrs: []string{"hdrs", "srcs"},
		NonEmptyAttrs: map[string]bool{
			"deps": true,
			"srcs": true,
			"hdrs": true,
		},
		MergeableAttrs: map[string]bool{
			"srcs": true,
			"hdrs": true,
		},
		ResolveAttrs: map[string]bool{"deps": true},
	},
	"cc_test": {
		MatchAttrs: []string{"srcs"},
		NonEmptyAttrs: map[string]bool{
			"deps": true,
			"srcs": true,
		},
		MergeableAttrs: map[string]bool{
			"srcs": true,
		},
		ResolveAttrs: map[string]bool{"deps": true},
	},
	"cc_binary": {
		MatchAttrs: []string{"srcs"},
		NonEmptyAttrs: map[string]bool{
			"deps": true,
			"srcs": true,
		},
		MergeableAttrs: map[string]bool{
			"srcs": true,
		},
		ResolveAttrs: map[string]bool{"deps": true},
	}}

// readCppData returns the imports and whether it is a main binary
func readCppData(path string) ([]string, bool, error) {
	f, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, false, fmt.Errorf("ioutil.ReadFile(%q) error: %v", path, err)
	}
	var imports []string
	for _, m := range cppImportRegex.FindAllStringSubmatch(string(f), -1) {
		imports = append(imports, m[1])
	}
	return imports, mainFunctionRegex.MatchString(string(f)), nil
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// A GenerateResult struct is returned. Optional fields may be added to this
// type in the future.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (e *Extension) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	if strings.HasPrefix(args.Rel, "external/") {
		return language.GenerateResult{}
	}
	// TODO copied from skylark
	ruleMap := map[string]*rule.Rule{}
	importMap := map[string][]string{}

	for _, f := range append(args.RegularFiles, args.GenFiles...) {
		if !isCppSourceFile(f) {
			continue
		}

		name := strings.TrimSuffix(f, filepath.Ext(f))

		fullPath := filepath.Join(args.Dir, f)
		loads, is_binary, err := readCppData(fullPath)
		if err != nil {
			log.Printf("%s: contains syntax errors: %v", fullPath, err)
			// Don't `continue` since it is reasonable to create a target even
			// without deps.
		}
		var r *rule.Rule
		is_test := cppTests.Matches(f)
		if is_binary {
			r = rule.NewRule("cc_binary", name)
		} else if is_test {
			r = rule.NewRule("cc_test", name)
		} else {
			r = rule.NewRule("cc_library", name)
		}

		if !(is_test || is_binary) && cppHdrs.Matches(f) {
			r.SetAttr("hdrs", []string{f})
		} else {
			r.SetAttr("srcs", []string{f})
		}

		if existing, ok := ruleMap[name]; ok {
			rule.SquashRules(r, existing, "__internal__")
			importMap[name] = append(importMap[name], loads...)
		} else {
			ruleMap[name] = r
			importMap[name] = loads
		}
	}
	var rules []*rule.Rule
	var imports []interface{}

	// sorting to keep output stable
	names := make([]string, 0, len(ruleMap))
	for name := range ruleMap {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		imports = append(imports, importMap[name])
		rules = append(rules, ruleMap[name])
	}
	// TODO merge duplicate rules?!

	return language.GenerateResult{
		Gen:     rules,
		Imports: imports,
		Empty:   generateEmpty(args),
	}
}

// generateEmpty generates the list of rules that don't need to exist in the
// BUILD file any more.
// For each bzl_library rule in args.File that only has srcs that aren't in
// args.RegularFiles or args.GenFiles, add a bzl_library with no srcs or deps.
// That will let Gazelle delete bzl_library rules after the corresponding .bzl
// files are deleted.
func generateEmpty(args language.GenerateArgs) []*rule.Rule {
	// TODO copied from skylark
	var ret []*rule.Rule
	if args.File == nil {
		return ret
	}
	for _, r := range args.File.Rules {
		// TODO handle tests and binaries?
		if r.Kind() != "cc_library" {
			continue
		}
		name := r.AttrString("name")

		exists := make(map[string]bool)
		for _, f := range args.RegularFiles {
			exists[f] = true
		}
		for _, f := range args.GenFiles {
			exists[f] = true
		}
		for _, r := range args.File.Rules {
			srcsExist := false
			for _, f := range append(r.AttrStrings("srcs"), r.AttrStrings("hdrs")...) {
				if exists[f] {
					srcsExist = true
					break
				}
			}
			if !srcsExist {
				ret = append(ret, rule.NewRule("bzl_library", name))
			}
		}
	}
	return ret
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
//
// Deprecated: Implement ModuleAwareLanguage's ApparentLoads.
func (e *Extension) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{{
		Name:    "@rules_cc//cc:defs.bzl",
		Symbols: []string{"cc_binary", "cc_library", "cc_test"},
	}}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (e *Extension) Fix(c *config.Config, f *rule.File) {}

// NewLanguage is called by Gazelle to install this language extension in a binary.
func NewLanguage() language.Language {
	return &Extension{}
}
